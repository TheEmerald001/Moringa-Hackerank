{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridDensityTypes } from '../../../models/gridDensity';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridDensitySelector } from './densitySelector';\nimport { isDeepEqual } from '../../../utils/utils';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector } from '../columns';\nimport { unwrapGroupingColumnModel } from '../columnGrouping/useGridColumnGrouping';\nexport const COMPACT_DENSITY_FACTOR = 0.7;\nexport const COMFORTABLE_DENSITY_FACTOR = 1.3; // TODO v6: revise keeping headerHeight and rowHeight in state\n\nconst getUpdatedDensityState = (newDensity, newHeaderHeight, newRowHeight, newMaxDepth) => {\n  switch (newDensity) {\n    case GridDensityTypes.Compact:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMPACT_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMPACT_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMPACT_DENSITY_FACTOR\n      };\n\n    case GridDensityTypes.Comfortable:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMFORTABLE_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMFORTABLE_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMFORTABLE_DENSITY_FACTOR\n      };\n\n    default:\n      return {\n        value: newDensity,\n        headerHeight: newHeaderHeight,\n        rowHeight: newRowHeight,\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: 1\n      };\n  }\n};\n\nexport const densityStateInitializer = (state, props) => {\n  // TODO: think about improving this initialization. Could it be done in the useColumn initializer?\n  // TODO: manage to remove ts-ignore\n  let maxDepth;\n\n  if (props.columnGroupingModel == null || Object.keys(props.columnGroupingModel).length === 0) {\n    maxDepth = 0;\n  } else {\n    const unwrappedGroupingColumnModel = unwrapGroupingColumnModel(props.columnGroupingModel);\n    const columnsState = state.columns;\n    const visibleColumns = columnsState.all.filter(field => columnsState.columnVisibilityModel[field] !== false);\n\n    if (visibleColumns.length === 0) {\n      maxDepth = 0;\n    } else {\n      maxDepth = Math.max(...visibleColumns.map(field => {\n        var _unwrappedGroupingCol, _unwrappedGroupingCol2;\n\n        return (_unwrappedGroupingCol = (_unwrappedGroupingCol2 = unwrappedGroupingColumnModel[field]) == null ? void 0 : _unwrappedGroupingCol2.length) != null ? _unwrappedGroupingCol : 0;\n      }));\n    }\n  }\n\n  return _extends({}, state, {\n    density: getUpdatedDensityState(props.density, props.headerHeight, props.rowHeight, maxDepth)\n  });\n};\nexport const useGridDensity = (apiRef, props) => {\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const maxDepth = visibleColumns.length > 0 ? Math.max(...visibleColumns.map(column => {\n    var _column$groupPath$len, _column$groupPath;\n\n    return (_column$groupPath$len = (_column$groupPath = column.groupPath) == null ? void 0 : _column$groupPath.length) != null ? _column$groupPath$len : 0;\n  })) : 0;\n  const logger = useGridLogger(apiRef, 'useDensity');\n  const setDensity = React.useCallback((newDensity, newHeaderHeight = props.headerHeight, newRowHeight = props.rowHeight, newMaxDepth = maxDepth) => {\n    logger.debug(`Set grid density to ${newDensity}`);\n    apiRef.current.setState(state => {\n      const currentDensityState = gridDensitySelector(state);\n      const newDensityState = getUpdatedDensityState(newDensity, newHeaderHeight, newRowHeight, newMaxDepth);\n\n      if (isDeepEqual(currentDensityState, newDensityState)) {\n        return state;\n      }\n\n      return _extends({}, state, {\n        density: newDensityState\n      });\n    });\n    apiRef.current.forceUpdate();\n  }, [logger, apiRef, props.headerHeight, props.rowHeight, maxDepth]);\n  React.useEffect(() => {\n    apiRef.current.setDensity(props.density, props.headerHeight, props.rowHeight, maxDepth);\n  }, [apiRef, props.density, props.rowHeight, props.headerHeight, maxDepth]);\n  const densityApi = {\n    setDensity\n  };\n  useGridApiMethod(apiRef, densityApi, 'GridDensityApi');\n};","map":{"version":3,"sources":["/home/shaki/phase-5-project/Moringa-Hackerank1/Moringa-Hackerank/client/node_modules/@mui/x-data-grid/hooks/features/density/useGridDensity.js"],"names":["_extends","React","GridDensityTypes","useGridLogger","useGridApiMethod","gridDensitySelector","isDeepEqual","useGridSelector","gridVisibleColumnDefinitionsSelector","unwrapGroupingColumnModel","COMPACT_DENSITY_FACTOR","COMFORTABLE_DENSITY_FACTOR","getUpdatedDensityState","newDensity","newHeaderHeight","newRowHeight","newMaxDepth","Compact","value","headerHeight","Math","floor","rowHeight","headerGroupingMaxDepth","factor","Comfortable","densityStateInitializer","state","props","maxDepth","columnGroupingModel","Object","keys","length","unwrappedGroupingColumnModel","columnsState","columns","visibleColumns","all","filter","field","columnVisibilityModel","max","map","_unwrappedGroupingCol","_unwrappedGroupingCol2","density","useGridDensity","apiRef","column","_column$groupPath$len","_column$groupPath","groupPath","logger","setDensity","useCallback","debug","current","setState","currentDensityState","newDensityState","forceUpdate","useEffect","densityApi"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridDensityTypes } from '../../../models/gridDensity';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridDensitySelector } from './densitySelector';\nimport { isDeepEqual } from '../../../utils/utils';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector } from '../columns';\nimport { unwrapGroupingColumnModel } from '../columnGrouping/useGridColumnGrouping';\nexport const COMPACT_DENSITY_FACTOR = 0.7;\nexport const COMFORTABLE_DENSITY_FACTOR = 1.3; // TODO v6: revise keeping headerHeight and rowHeight in state\n\nconst getUpdatedDensityState = (newDensity, newHeaderHeight, newRowHeight, newMaxDepth) => {\n  switch (newDensity) {\n    case GridDensityTypes.Compact:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMPACT_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMPACT_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMPACT_DENSITY_FACTOR\n      };\n\n    case GridDensityTypes.Comfortable:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMFORTABLE_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMFORTABLE_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMFORTABLE_DENSITY_FACTOR\n      };\n\n    default:\n      return {\n        value: newDensity,\n        headerHeight: newHeaderHeight,\n        rowHeight: newRowHeight,\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: 1\n      };\n  }\n};\n\nexport const densityStateInitializer = (state, props) => {\n  // TODO: think about improving this initialization. Could it be done in the useColumn initializer?\n  // TODO: manage to remove ts-ignore\n  let maxDepth;\n\n  if (props.columnGroupingModel == null || Object.keys(props.columnGroupingModel).length === 0) {\n    maxDepth = 0;\n  } else {\n    const unwrappedGroupingColumnModel = unwrapGroupingColumnModel(props.columnGroupingModel);\n    const columnsState = state.columns;\n    const visibleColumns = columnsState.all.filter(field => columnsState.columnVisibilityModel[field] !== false);\n\n    if (visibleColumns.length === 0) {\n      maxDepth = 0;\n    } else {\n      maxDepth = Math.max(...visibleColumns.map(field => {\n        var _unwrappedGroupingCol, _unwrappedGroupingCol2;\n\n        return (_unwrappedGroupingCol = (_unwrappedGroupingCol2 = unwrappedGroupingColumnModel[field]) == null ? void 0 : _unwrappedGroupingCol2.length) != null ? _unwrappedGroupingCol : 0;\n      }));\n    }\n  }\n\n  return _extends({}, state, {\n    density: getUpdatedDensityState(props.density, props.headerHeight, props.rowHeight, maxDepth)\n  });\n};\nexport const useGridDensity = (apiRef, props) => {\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const maxDepth = visibleColumns.length > 0 ? Math.max(...visibleColumns.map(column => {\n    var _column$groupPath$len, _column$groupPath;\n\n    return (_column$groupPath$len = (_column$groupPath = column.groupPath) == null ? void 0 : _column$groupPath.length) != null ? _column$groupPath$len : 0;\n  })) : 0;\n  const logger = useGridLogger(apiRef, 'useDensity');\n  const setDensity = React.useCallback((newDensity, newHeaderHeight = props.headerHeight, newRowHeight = props.rowHeight, newMaxDepth = maxDepth) => {\n    logger.debug(`Set grid density to ${newDensity}`);\n    apiRef.current.setState(state => {\n      const currentDensityState = gridDensitySelector(state);\n      const newDensityState = getUpdatedDensityState(newDensity, newHeaderHeight, newRowHeight, newMaxDepth);\n\n      if (isDeepEqual(currentDensityState, newDensityState)) {\n        return state;\n      }\n\n      return _extends({}, state, {\n        density: newDensityState\n      });\n    });\n    apiRef.current.forceUpdate();\n  }, [logger, apiRef, props.headerHeight, props.rowHeight, maxDepth]);\n  React.useEffect(() => {\n    apiRef.current.setDensity(props.density, props.headerHeight, props.rowHeight, maxDepth);\n  }, [apiRef, props.density, props.rowHeight, props.headerHeight, maxDepth]);\n  const densityApi = {\n    setDensity\n  };\n  useGridApiMethod(apiRef, densityApi, 'GridDensityApi');\n};"]},"metadata":{},"sourceType":"module"}