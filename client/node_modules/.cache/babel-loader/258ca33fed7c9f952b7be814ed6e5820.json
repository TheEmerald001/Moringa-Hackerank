{"ast":null,"code":"import * as React from 'react';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnPositionsSelector, gridVisibleColumnDefinitionsSelector } from '../columns/gridColumnsSelector';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridPageSelector, gridPageSizeSelector } from '../pagination/gridPaginationSelector';\nimport { gridRowCountSelector } from '../rows/gridRowsSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridVisibleSortedRowEntriesSelector } from '../filter/gridFilterSelector';\nimport { gridClasses } from '../../../constants/gridClasses'; // Logic copied from https://www.w3.org/TR/wai-aria-practices/examples/listbox/js/listbox.js\n// Similar to https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView\n\nfunction scrollIntoView(dimensions) {\n  const {\n    clientHeight,\n    scrollTop,\n    offsetHeight,\n    offsetTop\n  } = dimensions;\n  const elementBottom = offsetTop + offsetHeight; // Always scroll to top when cell is higher than viewport to avoid scroll jump\n  // See https://github.com/mui/mui-x/issues/4513 and https://github.com/mui/mui-x/issues/4514\n\n  if (offsetHeight > clientHeight) {\n    return offsetTop;\n  }\n\n  if (elementBottom - clientHeight > scrollTop) {\n    return elementBottom - clientHeight;\n  }\n\n  if (offsetTop < scrollTop) {\n    return offsetTop;\n  }\n\n  return undefined;\n}\n/**\n * @requires useGridPagination (state) - can be after, async only\n * @requires useGridColumns (state) - can be after, async only\n * @requires useGridRows (state) - can be after, async only\n * @requires useGridRowsMeta (state) - can be after, async only\n * @requires useGridFilter (state)\n * @requires useGridColumnSpanning (method)\n */\n\n\nexport const useGridScroll = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridScroll');\n  const colRef = apiRef.current.columnHeadersElementRef;\n  const windowRef = apiRef.current.windowRef;\n  const visibleSortedRows = useGridSelector(apiRef, gridVisibleSortedRowEntriesSelector);\n  const scrollToIndexes = React.useCallback(params => {\n    const totalRowCount = gridRowCountSelector(apiRef);\n    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n    const scrollToHeader = params.rowIndex == null;\n\n    if (!scrollToHeader && totalRowCount === 0 || visibleColumns.length === 0) {\n      return false;\n    }\n\n    logger.debug(`Scrolling to cell at row ${params.rowIndex}, col: ${params.colIndex} `);\n    let scrollCoordinates = {};\n\n    if (params.colIndex != null) {\n      const columnPositions = gridColumnPositionsSelector(apiRef);\n      let cellWidth;\n\n      if (typeof params.rowIndex !== 'undefined') {\n        var _visibleSortedRows$pa;\n\n        const rowId = (_visibleSortedRows$pa = visibleSortedRows[params.rowIndex]) == null ? void 0 : _visibleSortedRows$pa.id;\n        const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, params.colIndex);\n\n        if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {\n          cellWidth = cellColSpanInfo.cellProps.width;\n        }\n      }\n\n      if (typeof cellWidth === 'undefined') {\n        cellWidth = visibleColumns[params.colIndex].computedWidth;\n      }\n\n      scrollCoordinates.left = scrollIntoView({\n        clientHeight: windowRef.current.clientWidth,\n        scrollTop: windowRef.current.scrollLeft,\n        offsetHeight: cellWidth,\n        offsetTop: columnPositions[params.colIndex]\n      });\n    }\n\n    if (params.rowIndex != null) {\n      var _querySelector, _querySelector2;\n\n      const rowsMeta = gridRowsMetaSelector(apiRef.current.state);\n      const page = gridPageSelector(apiRef);\n      const pageSize = gridPageSizeSelector(apiRef);\n      const elementIndex = !props.pagination ? params.rowIndex : params.rowIndex - page * pageSize;\n      const targetOffsetHeight = rowsMeta.positions[elementIndex + 1] ? rowsMeta.positions[elementIndex + 1] - rowsMeta.positions[elementIndex] : rowsMeta.currentPageTotalHeight - rowsMeta.positions[elementIndex];\n      const topPinnedRowsHeight = ((_querySelector = windowRef.current.querySelector(`.${gridClasses['pinnedRows--top']}`)) == null ? void 0 : _querySelector.clientHeight) || 0;\n      const bottomPinnedRowsHeight = ((_querySelector2 = windowRef.current.querySelector(`.${gridClasses['pinnedRows--bottom']}`)) == null ? void 0 : _querySelector2.clientHeight) || 0;\n      scrollCoordinates.top = scrollIntoView({\n        clientHeight: windowRef.current.clientHeight - topPinnedRowsHeight - bottomPinnedRowsHeight,\n        scrollTop: windowRef.current.scrollTop,\n        offsetHeight: targetOffsetHeight,\n        offsetTop: rowsMeta.positions[elementIndex]\n      });\n    }\n\n    scrollCoordinates = apiRef.current.unstable_applyPipeProcessors('scrollToIndexes', scrollCoordinates, params);\n\n    if (typeof scrollCoordinates.left !== undefined || typeof scrollCoordinates.top !== undefined) {\n      apiRef.current.scroll(scrollCoordinates);\n      return true;\n    }\n\n    return false;\n  }, [logger, apiRef, windowRef, props.pagination, visibleSortedRows]);\n  const scroll = React.useCallback(params => {\n    if (windowRef.current && params.left != null && colRef.current) {\n      colRef.current.scrollLeft = params.left;\n      windowRef.current.scrollLeft = params.left;\n      logger.debug(`Scrolling left: ${params.left}`);\n    }\n\n    if (windowRef.current && params.top != null) {\n      windowRef.current.scrollTop = params.top;\n      logger.debug(`Scrolling top: ${params.top}`);\n    }\n\n    logger.debug(`Scrolling, updating container, and viewport`);\n  }, [windowRef, colRef, logger]);\n  const getScrollPosition = React.useCallback(() => {\n    if (!(windowRef != null && windowRef.current)) {\n      return {\n        top: 0,\n        left: 0\n      };\n    }\n\n    return {\n      top: windowRef.current.scrollTop,\n      left: windowRef.current.scrollLeft\n    };\n  }, [windowRef]);\n  const scrollApi = {\n    scroll,\n    scrollToIndexes,\n    getScrollPosition\n  };\n  useGridApiMethod(apiRef, scrollApi, 'GridScrollApi');\n};","map":{"version":3,"sources":["/home/shaki/phase-5-project/Moringa-Hackerank1/Moringa-Hackerank/client/node_modules/@mui/x-data-grid/hooks/features/scroll/useGridScroll.js"],"names":["React","useGridLogger","gridColumnPositionsSelector","gridVisibleColumnDefinitionsSelector","useGridSelector","gridPageSelector","gridPageSizeSelector","gridRowCountSelector","gridRowsMetaSelector","useGridApiMethod","gridVisibleSortedRowEntriesSelector","gridClasses","scrollIntoView","dimensions","clientHeight","scrollTop","offsetHeight","offsetTop","elementBottom","undefined","useGridScroll","apiRef","props","logger","colRef","current","columnHeadersElementRef","windowRef","visibleSortedRows","scrollToIndexes","useCallback","params","totalRowCount","visibleColumns","scrollToHeader","rowIndex","length","debug","colIndex","scrollCoordinates","columnPositions","cellWidth","_visibleSortedRows$pa","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","cellProps","width","computedWidth","left","clientWidth","scrollLeft","_querySelector","_querySelector2","rowsMeta","state","page","pageSize","elementIndex","pagination","targetOffsetHeight","positions","currentPageTotalHeight","topPinnedRowsHeight","querySelector","bottomPinnedRowsHeight","top","unstable_applyPipeProcessors","scroll","getScrollPosition","scrollApi"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnPositionsSelector, gridVisibleColumnDefinitionsSelector } from '../columns/gridColumnsSelector';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridPageSelector, gridPageSizeSelector } from '../pagination/gridPaginationSelector';\nimport { gridRowCountSelector } from '../rows/gridRowsSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridVisibleSortedRowEntriesSelector } from '../filter/gridFilterSelector';\nimport { gridClasses } from '../../../constants/gridClasses'; // Logic copied from https://www.w3.org/TR/wai-aria-practices/examples/listbox/js/listbox.js\n// Similar to https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView\n\nfunction scrollIntoView(dimensions) {\n  const {\n    clientHeight,\n    scrollTop,\n    offsetHeight,\n    offsetTop\n  } = dimensions;\n  const elementBottom = offsetTop + offsetHeight; // Always scroll to top when cell is higher than viewport to avoid scroll jump\n  // See https://github.com/mui/mui-x/issues/4513 and https://github.com/mui/mui-x/issues/4514\n\n  if (offsetHeight > clientHeight) {\n    return offsetTop;\n  }\n\n  if (elementBottom - clientHeight > scrollTop) {\n    return elementBottom - clientHeight;\n  }\n\n  if (offsetTop < scrollTop) {\n    return offsetTop;\n  }\n\n  return undefined;\n}\n/**\n * @requires useGridPagination (state) - can be after, async only\n * @requires useGridColumns (state) - can be after, async only\n * @requires useGridRows (state) - can be after, async only\n * @requires useGridRowsMeta (state) - can be after, async only\n * @requires useGridFilter (state)\n * @requires useGridColumnSpanning (method)\n */\n\n\nexport const useGridScroll = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridScroll');\n  const colRef = apiRef.current.columnHeadersElementRef;\n  const windowRef = apiRef.current.windowRef;\n  const visibleSortedRows = useGridSelector(apiRef, gridVisibleSortedRowEntriesSelector);\n  const scrollToIndexes = React.useCallback(params => {\n    const totalRowCount = gridRowCountSelector(apiRef);\n    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n    const scrollToHeader = params.rowIndex == null;\n\n    if (!scrollToHeader && totalRowCount === 0 || visibleColumns.length === 0) {\n      return false;\n    }\n\n    logger.debug(`Scrolling to cell at row ${params.rowIndex}, col: ${params.colIndex} `);\n    let scrollCoordinates = {};\n\n    if (params.colIndex != null) {\n      const columnPositions = gridColumnPositionsSelector(apiRef);\n      let cellWidth;\n\n      if (typeof params.rowIndex !== 'undefined') {\n        var _visibleSortedRows$pa;\n\n        const rowId = (_visibleSortedRows$pa = visibleSortedRows[params.rowIndex]) == null ? void 0 : _visibleSortedRows$pa.id;\n        const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, params.colIndex);\n\n        if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {\n          cellWidth = cellColSpanInfo.cellProps.width;\n        }\n      }\n\n      if (typeof cellWidth === 'undefined') {\n        cellWidth = visibleColumns[params.colIndex].computedWidth;\n      }\n\n      scrollCoordinates.left = scrollIntoView({\n        clientHeight: windowRef.current.clientWidth,\n        scrollTop: windowRef.current.scrollLeft,\n        offsetHeight: cellWidth,\n        offsetTop: columnPositions[params.colIndex]\n      });\n    }\n\n    if (params.rowIndex != null) {\n      var _querySelector, _querySelector2;\n\n      const rowsMeta = gridRowsMetaSelector(apiRef.current.state);\n      const page = gridPageSelector(apiRef);\n      const pageSize = gridPageSizeSelector(apiRef);\n      const elementIndex = !props.pagination ? params.rowIndex : params.rowIndex - page * pageSize;\n      const targetOffsetHeight = rowsMeta.positions[elementIndex + 1] ? rowsMeta.positions[elementIndex + 1] - rowsMeta.positions[elementIndex] : rowsMeta.currentPageTotalHeight - rowsMeta.positions[elementIndex];\n      const topPinnedRowsHeight = ((_querySelector = windowRef.current.querySelector(`.${gridClasses['pinnedRows--top']}`)) == null ? void 0 : _querySelector.clientHeight) || 0;\n      const bottomPinnedRowsHeight = ((_querySelector2 = windowRef.current.querySelector(`.${gridClasses['pinnedRows--bottom']}`)) == null ? void 0 : _querySelector2.clientHeight) || 0;\n      scrollCoordinates.top = scrollIntoView({\n        clientHeight: windowRef.current.clientHeight - topPinnedRowsHeight - bottomPinnedRowsHeight,\n        scrollTop: windowRef.current.scrollTop,\n        offsetHeight: targetOffsetHeight,\n        offsetTop: rowsMeta.positions[elementIndex]\n      });\n    }\n\n    scrollCoordinates = apiRef.current.unstable_applyPipeProcessors('scrollToIndexes', scrollCoordinates, params);\n\n    if (typeof scrollCoordinates.left !== undefined || typeof scrollCoordinates.top !== undefined) {\n      apiRef.current.scroll(scrollCoordinates);\n      return true;\n    }\n\n    return false;\n  }, [logger, apiRef, windowRef, props.pagination, visibleSortedRows]);\n  const scroll = React.useCallback(params => {\n    if (windowRef.current && params.left != null && colRef.current) {\n      colRef.current.scrollLeft = params.left;\n      windowRef.current.scrollLeft = params.left;\n      logger.debug(`Scrolling left: ${params.left}`);\n    }\n\n    if (windowRef.current && params.top != null) {\n      windowRef.current.scrollTop = params.top;\n      logger.debug(`Scrolling top: ${params.top}`);\n    }\n\n    logger.debug(`Scrolling, updating container, and viewport`);\n  }, [windowRef, colRef, logger]);\n  const getScrollPosition = React.useCallback(() => {\n    if (!(windowRef != null && windowRef.current)) {\n      return {\n        top: 0,\n        left: 0\n      };\n    }\n\n    return {\n      top: windowRef.current.scrollTop,\n      left: windowRef.current.scrollLeft\n    };\n  }, [windowRef]);\n  const scrollApi = {\n    scroll,\n    scrollToIndexes,\n    getScrollPosition\n  };\n  useGridApiMethod(apiRef, scrollApi, 'GridScrollApi');\n};"]},"metadata":{},"sourceType":"module"}