{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { debounce, capitalize } from '@mui/material/utils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nexport const rowsMetaStateInitializer = state => _extends({}, state, {\n  rowsMeta: {\n    currentPageTotalHeight: 0,\n    positions: []\n  }\n});\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  const paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const hydrateRowsMeta = React.useCallback(() => {\n    var _pinnedRows$top, _pinnedRows$bottom;\n\n    hasRowWithAutoHeight.current = false;\n    const densityFactor = gridDensityFactorSelector(apiRef.current.state, apiRef.current.instanceId);\n\n    const calculateRowProcessedSizes = row => {\n      if (!rowsHeightLookup.current[row.id]) {\n        rowsHeightLookup.current[row.id] = {\n          sizes: {\n            baseCenter: rowHeightFromDensity\n          },\n          isResized: false,\n          autoHeight: false,\n          needsFirstMeasurement: true // Assume all rows will need to be measured by default\n\n        };\n      }\n\n      const {\n        isResized,\n        needsFirstMeasurement,\n        sizes\n      } = rowsHeightLookup.current[row.id];\n      let baseRowHeight = rowHeightFromDensity;\n      const existingBaseRowHeight = sizes.baseCenter;\n\n      if (isResized) {\n        // Do not recalculate resized row height and use the value from the lookup\n        baseRowHeight = existingBaseRowHeight;\n      } else if (getRowHeightProp) {\n        const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n          densityFactor\n        }));\n\n        if (rowHeightFromUser === 'auto') {\n          if (needsFirstMeasurement) {\n            const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n              densityFactor\n            })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n          } else {\n            baseRowHeight = existingBaseRowHeight;\n          }\n\n          hasRowWithAutoHeight.current = true;\n          rowsHeightLookup.current[row.id].autoHeight = true;\n        } else {\n          // Default back to base rowHeight if getRowHeight returns null or undefined.\n          baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n          rowsHeightLookup.current[row.id].autoHeight = false;\n        }\n      } else {\n        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n      }\n\n      const existingBaseSizes = Object.entries(sizes).reduce((acc, [key, size]) => {\n        if (/^base[A-Z]/.test(key)) {\n          acc[key] = size;\n        }\n\n        return acc;\n      }, {}); // We use an object to make simple to check if a height is already added or not\n\n      const initialHeights = _extends({}, existingBaseSizes, {\n        baseCenter: baseRowHeight\n      });\n\n      if (getRowSpacing) {\n        var _spacing$top, _spacing$bottom;\n\n        const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n        const spacing = getRowSpacing(_extends({}, row, {\n          isFirstVisible: indexRelativeToCurrentPage === 0,\n          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n          indexRelativeToCurrentPage\n        }));\n        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n      }\n\n      const processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n      rowsHeightLookup.current[row.id].sizes = processedSizes;\n      return processedSizes;\n    };\n\n    const positions = [];\n    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n      positions.push(acc);\n      let maximumBaseSize = 0;\n      let otherSizes = 0;\n      const processedSizes = calculateRowProcessedSizes(row);\n      Object.entries(processedSizes).forEach(([size, value]) => {\n        if (/^base[A-Z]/.test(size)) {\n          maximumBaseSize = value > maximumBaseSize ? value : maximumBaseSize;\n        } else {\n          otherSizes += value;\n        }\n      });\n      return acc + maximumBaseSize + otherSizes;\n    }, 0);\n    pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight,\n          positions\n        }\n      });\n    });\n\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows]);\n  const getRowHeight = React.useCallback(rowId => {\n    const height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.baseCenter : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n\n  const getRowInternalSizes = rowId => {\n    var _rowsHeightLookup$cur;\n\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n\n  const setRowHeight = React.useCallback((id, height) => {\n    rowsHeightLookup.current[id].sizes.baseCenter = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const debouncedHydrateRowsMeta = React.useMemo(() => debounce(hydrateRowsMeta), [hydrateRowsMeta]);\n  const storeMeasuredRowHeight = React.useCallback((id, height, position) => {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n\n    const needsHydration = rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] = height;\n\n    if (needsHydration) {\n      debouncedHydrateRowsMeta();\n    }\n  }, [debouncedHydrateRowsMeta]);\n  const rowHasAutoHeight = React.useCallback(id => {\n    var _rowsHeightLookup$cur2;\n\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  const getLastMeasuredRowIndex = React.useCallback(() => {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  const setLastMeasuredRowIndex = React.useCallback(index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []);\n  const resetRowHeights = React.useCallback(() => {\n    rowsHeightLookup.current = {};\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(() => {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  const rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight,\n    resetRowHeights\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};","map":{"version":3,"sources":["/home/shaki/phase-5-project/Moringa-Hackerank1/Moringa-Hackerank/client/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowsMeta.js"],"names":["_extends","React","debounce","capitalize","useGridVisibleRows","useGridApiMethod","useGridSelector","gridDensityRowHeightSelector","gridDensityFactorSelector","gridFilterStateSelector","gridPaginationSelector","gridSortingStateSelector","useGridRegisterPipeApplier","gridPinnedRowsSelector","rowsMetaStateInitializer","state","rowsMeta","currentPageTotalHeight","positions","useGridRowsMeta","apiRef","props","getRowHeight","getRowHeightProp","getRowSpacing","getEstimatedRowHeight","rowsHeightLookup","useRef","lastMeasuredRowIndex","hasRowWithAutoHeight","rowHeightFromDensity","filterState","paginationState","sortingState","currentPage","pinnedRows","hydrateRowsMeta","useCallback","_pinnedRows$top","_pinnedRows$bottom","current","densityFactor","instanceId","calculateRowProcessedSizes","row","id","sizes","baseCenter","isResized","autoHeight","needsFirstMeasurement","baseRowHeight","existingBaseRowHeight","rowHeightFromUser","estimatedRowHeight","existingBaseSizes","Object","entries","reduce","acc","key","size","test","initialHeights","_spacing$top","_spacing$bottom","indexRelativeToCurrentPage","getRowIndexRelativeToVisibleRows","spacing","isFirstVisible","isLastVisible","rows","length","spacingTop","top","spacingBottom","bottom","processedSizes","unstable_applyPipeProcessors","push","maximumBaseSize","otherSizes","forEach","value","setState","Infinity","forceUpdate","rowId","height","getRowInternalSizes","_rowsHeightLookup$cur","setRowHeight","debouncedHydrateRowsMeta","useMemo","storeMeasuredRowHeight","position","needsHydration","rowHasAutoHeight","_rowsHeightLookup$cur2","getLastMeasuredRowIndex","setLastMeasuredRowIndex","index","resetRowHeights","useEffect","rowsMetaApi","unstable_getLastMeasuredRowIndex","unstable_setLastMeasuredRowIndex","unstable_rowHasAutoHeight","unstable_getRowHeight","unstable_getRowInternalSizes","unstable_setRowHeight","unstable_storeRowHeightMeasurement"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,QAAT,EAAmBC,UAAnB,QAAqC,qBAArC;AACA,SAASC,kBAAT,QAAmC,gCAAnC;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA,SAASC,eAAT,QAAgC,6BAAhC;AACA,SAASC,4BAAT,EAAuCC,yBAAvC,QAAwE,4BAAxE;AACA,SAASC,uBAAT,QAAwC,8BAAxC;AACA,SAASC,sBAAT,QAAuC,sCAAvC;AACA,SAASC,wBAAT,QAAyC,gCAAzC;AACA,SAASC,0BAAT,QAA2C,2BAA3C;AACA,SAASC,sBAAT,QAAuC,oBAAvC;AACA,OAAO,MAAMC,wBAAwB,GAAGC,KAAK,IAAIf,QAAQ,CAAC,EAAD,EAAKe,KAAL,EAAY;AACnEC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,sBAAsB,EAAE,CADhB;AAERC,IAAAA,SAAS,EAAE;AAFH;AADyD,CAAZ,CAAlD;AAMP;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,eAAe,GAAG,CAACC,MAAD,EAASC,KAAT,KAAmB;AAChD,QAAM;AACJC,IAAAA,YAAY,EAAEC,gBADV;AAEJC,IAAAA,aAFI;AAGJC,IAAAA;AAHI,MAIFJ,KAJJ;AAKA,QAAMK,gBAAgB,GAAGzB,KAAK,CAAC0B,MAAN,CAAa,EAAb,CAAzB,CANgD,CAML;;AAE3C,QAAMC,oBAAoB,GAAG3B,KAAK,CAAC0B,MAAN,CAAa,CAAC,CAAd,CAA7B;AACA,QAAME,oBAAoB,GAAG5B,KAAK,CAAC0B,MAAN,CAAa,KAAb,CAA7B;AACA,QAAMG,oBAAoB,GAAGxB,eAAe,CAACc,MAAD,EAASb,4BAAT,CAA5C;AACA,QAAMwB,WAAW,GAAGzB,eAAe,CAACc,MAAD,EAASX,uBAAT,CAAnC;AACA,QAAMuB,eAAe,GAAG1B,eAAe,CAACc,MAAD,EAASV,sBAAT,CAAvC;AACA,QAAMuB,YAAY,GAAG3B,eAAe,CAACc,MAAD,EAAST,wBAAT,CAApC;AACA,QAAMuB,WAAW,GAAG9B,kBAAkB,CAACgB,MAAD,EAASC,KAAT,CAAtC;AACA,QAAMc,UAAU,GAAG7B,eAAe,CAACc,MAAD,EAASP,sBAAT,CAAlC;AACA,QAAMuB,eAAe,GAAGnC,KAAK,CAACoC,WAAN,CAAkB,MAAM;AAC9C,QAAIC,eAAJ,EAAqBC,kBAArB;;AAEAV,IAAAA,oBAAoB,CAACW,OAArB,GAA+B,KAA/B;AACA,UAAMC,aAAa,GAAGjC,yBAAyB,CAACY,MAAM,CAACoB,OAAP,CAAezB,KAAhB,EAAuBK,MAAM,CAACoB,OAAP,CAAeE,UAAtC,CAA/C;;AAEA,UAAMC,0BAA0B,GAAGC,GAAG,IAAI;AACxC,UAAI,CAAClB,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,CAAL,EAAuC;AACrCnB,QAAAA,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,IAAmC;AACjCC,UAAAA,KAAK,EAAE;AACLC,YAAAA,UAAU,EAAEjB;AADP,WAD0B;AAIjCkB,UAAAA,SAAS,EAAE,KAJsB;AAKjCC,UAAAA,UAAU,EAAE,KALqB;AAMjCC,UAAAA,qBAAqB,EAAE,IANU,CAML;;AANK,SAAnC;AASD;;AAED,YAAM;AACJF,QAAAA,SADI;AAEJE,QAAAA,qBAFI;AAGJJ,QAAAA;AAHI,UAIFpB,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,CAJJ;AAKA,UAAIM,aAAa,GAAGrB,oBAApB;AACA,YAAMsB,qBAAqB,GAAGN,KAAK,CAACC,UAApC;;AAEA,UAAIC,SAAJ,EAAe;AACb;AACAG,QAAAA,aAAa,GAAGC,qBAAhB;AACD,OAHD,MAGO,IAAI7B,gBAAJ,EAAsB;AAC3B,cAAM8B,iBAAiB,GAAG9B,gBAAgB,CAACvB,QAAQ,CAAC,EAAD,EAAK4C,GAAL,EAAU;AAC3DH,UAAAA;AAD2D,SAAV,CAAT,CAA1C;;AAIA,YAAIY,iBAAiB,KAAK,MAA1B,EAAkC;AAChC,cAAIH,qBAAJ,EAA2B;AACzB,kBAAMI,kBAAkB,GAAG7B,qBAAqB,GAAGA,qBAAqB,CAACzB,QAAQ,CAAC,EAAD,EAAK4C,GAAL,EAAU;AACzFH,cAAAA;AADyF,aAAV,CAAT,CAAxB,GAE1CX,oBAFN,CADyB,CAGG;;AAE5BqB,YAAAA,aAAa,GAAGG,kBAAkB,IAAI,IAAtB,GAA6BA,kBAA7B,GAAkDxB,oBAAlE;AACD,WAND,MAMO;AACLqB,YAAAA,aAAa,GAAGC,qBAAhB;AACD;;AAEDvB,UAAAA,oBAAoB,CAACW,OAArB,GAA+B,IAA/B;AACAd,UAAAA,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,EAAiCI,UAAjC,GAA8C,IAA9C;AACD,SAbD,MAaO;AACL;AACAE,UAAAA,aAAa,GAAGE,iBAAiB,IAAI,IAArB,GAA4BA,iBAA5B,GAAgDvB,oBAAhE;AACAJ,UAAAA,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,EAAiCK,qBAAjC,GAAyD,KAAzD;AACAxB,UAAAA,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,EAAiCI,UAAjC,GAA8C,KAA9C;AACD;AACF,OAxBM,MAwBA;AACLvB,QAAAA,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,EAAiCK,qBAAjC,GAAyD,KAAzD;AACD;;AAED,YAAMK,iBAAiB,GAAGC,MAAM,CAACC,OAAP,CAAeX,KAAf,EAAsBY,MAAtB,CAA6B,CAACC,GAAD,EAAM,CAACC,GAAD,EAAMC,IAAN,CAAN,KAAsB;AAC3E,YAAI,aAAaC,IAAb,CAAkBF,GAAlB,CAAJ,EAA4B;AAC1BD,UAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,IAAX;AACD;;AAED,eAAOF,GAAP;AACD,OANyB,EAMvB,EANuB,CAA1B,CApDwC,CA0DhC;;AAER,YAAMI,cAAc,GAAG/D,QAAQ,CAAC,EAAD,EAAKuD,iBAAL,EAAwB;AACrDR,QAAAA,UAAU,EAAEI;AADyC,OAAxB,CAA/B;;AAIA,UAAI3B,aAAJ,EAAmB;AACjB,YAAIwC,YAAJ,EAAkBC,eAAlB;;AAEA,cAAMC,0BAA0B,GAAG9C,MAAM,CAACoB,OAAP,CAAe2B,gCAAf,CAAgDvB,GAAG,CAACC,EAApD,CAAnC;AACA,cAAMuB,OAAO,GAAG5C,aAAa,CAACxB,QAAQ,CAAC,EAAD,EAAK4C,GAAL,EAAU;AAC9CyB,UAAAA,cAAc,EAAEH,0BAA0B,KAAK,CADD;AAE9CI,UAAAA,aAAa,EAAEJ,0BAA0B,KAAKhC,WAAW,CAACqC,IAAZ,CAAiBC,MAAjB,GAA0B,CAF1B;AAG9CN,UAAAA;AAH8C,SAAV,CAAT,CAA7B;AAKAH,QAAAA,cAAc,CAACU,UAAf,GAA4B,CAACT,YAAY,GAAGI,OAAO,CAACM,GAAxB,KAAgC,IAAhC,GAAuCV,YAAvC,GAAsD,CAAlF;AACAD,QAAAA,cAAc,CAACY,aAAf,GAA+B,CAACV,eAAe,GAAGG,OAAO,CAACQ,MAA3B,KAAsC,IAAtC,GAA6CX,eAA7C,GAA+D,CAA9F;AACD;;AAED,YAAMY,cAAc,GAAGzD,MAAM,CAACoB,OAAP,CAAesC,4BAAf,CAA4C,WAA5C,EAAyDf,cAAzD,EAAyEnB,GAAzE,CAAvB;AACAlB,MAAAA,gBAAgB,CAACc,OAAjB,CAAyBI,GAAG,CAACC,EAA7B,EAAiCC,KAAjC,GAAyC+B,cAAzC;AACA,aAAOA,cAAP;AACD,KAhFD;;AAkFA,UAAM3D,SAAS,GAAG,EAAlB;AACA,UAAMD,sBAAsB,GAAGiB,WAAW,CAACqC,IAAZ,CAAiBb,MAAjB,CAAwB,CAACC,GAAD,EAAMf,GAAN,KAAc;AACnE1B,MAAAA,SAAS,CAAC6D,IAAV,CAAepB,GAAf;AACA,UAAIqB,eAAe,GAAG,CAAtB;AACA,UAAIC,UAAU,GAAG,CAAjB;AACA,YAAMJ,cAAc,GAAGlC,0BAA0B,CAACC,GAAD,CAAjD;AACAY,MAAAA,MAAM,CAACC,OAAP,CAAeoB,cAAf,EAA+BK,OAA/B,CAAuC,CAAC,CAACrB,IAAD,EAAOsB,KAAP,CAAD,KAAmB;AACxD,YAAI,aAAarB,IAAb,CAAkBD,IAAlB,CAAJ,EAA6B;AAC3BmB,UAAAA,eAAe,GAAGG,KAAK,GAAGH,eAAR,GAA0BG,KAA1B,GAAkCH,eAApD;AACD,SAFD,MAEO;AACLC,UAAAA,UAAU,IAAIE,KAAd;AACD;AACF,OAND;AAOA,aAAOxB,GAAG,GAAGqB,eAAN,GAAwBC,UAA/B;AACD,KAb8B,EAa5B,CAb4B,CAA/B;AAcA9C,IAAAA,UAAU,IAAI,IAAd,GAAqB,KAAK,CAA1B,GAA8B,CAACG,eAAe,GAAGH,UAAU,CAACuC,GAA9B,KAAsC,IAAtC,GAA6C,KAAK,CAAlD,GAAsDpC,eAAe,CAAC4C,OAAhB,CAAwBtC,GAAG,IAAI;AACjHD,MAAAA,0BAA0B,CAACC,GAAD,CAA1B;AACD,KAFmF,CAApF;AAGAT,IAAAA,UAAU,IAAI,IAAd,GAAqB,KAAK,CAA1B,GAA8B,CAACI,kBAAkB,GAAGJ,UAAU,CAACyC,MAAjC,KAA4C,IAA5C,GAAmD,KAAK,CAAxD,GAA4DrC,kBAAkB,CAAC2C,OAAnB,CAA2BtC,GAAG,IAAI;AAC1HD,MAAAA,0BAA0B,CAACC,GAAD,CAA1B;AACD,KAFyF,CAA1F;AAGAxB,IAAAA,MAAM,CAACoB,OAAP,CAAe4C,QAAf,CAAwBrE,KAAK,IAAI;AAC/B,aAAOf,QAAQ,CAAC,EAAD,EAAKe,KAAL,EAAY;AACzBC,QAAAA,QAAQ,EAAE;AACRC,UAAAA,sBADQ;AAERC,UAAAA;AAFQ;AADe,OAAZ,CAAf;AAMD,KAPD;;AASA,QAAI,CAACW,oBAAoB,CAACW,OAA1B,EAAmC;AACjC;AACAZ,MAAAA,oBAAoB,CAACY,OAArB,GAA+B6C,QAA/B;AACD;;AAEDjE,IAAAA,MAAM,CAACoB,OAAP,CAAe8C,WAAf;AACD,GA5HuB,EA4HrB,CAAClE,MAAD,EAASc,WAAW,CAACqC,IAArB,EAA2BzC,oBAA3B,EAAiDP,gBAAjD,EAAmEC,aAAnE,EAAkFC,qBAAlF,EAAyGU,UAAzG,CA5HqB,CAAxB;AA6HA,QAAMb,YAAY,GAAGrB,KAAK,CAACoC,WAAN,CAAkBkD,KAAK,IAAI;AAC9C,UAAMC,MAAM,GAAG9D,gBAAgB,CAACc,OAAjB,CAAyB+C,KAAzB,CAAf;AACA,WAAOC,MAAM,GAAGA,MAAM,CAAC1C,KAAP,CAAaC,UAAhB,GAA6BjB,oBAA1C;AACD,GAHoB,EAGlB,CAACA,oBAAD,CAHkB,CAArB;;AAKA,QAAM2D,mBAAmB,GAAGF,KAAK,IAAI;AACnC,QAAIG,qBAAJ;;AAEA,WAAO,CAACA,qBAAqB,GAAGhE,gBAAgB,CAACc,OAAjB,CAAyB+C,KAAzB,CAAzB,KAA6D,IAA7D,GAAoE,KAAK,CAAzE,GAA6EG,qBAAqB,CAAC5C,KAA1G;AACD,GAJD;;AAMA,QAAM6C,YAAY,GAAG1F,KAAK,CAACoC,WAAN,CAAkB,CAACQ,EAAD,EAAK2C,MAAL,KAAgB;AACrD9D,IAAAA,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,EAA6BC,KAA7B,CAAmCC,UAAnC,GAAgDyC,MAAhD;AACA9D,IAAAA,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,EAA6BG,SAA7B,GAAyC,IAAzC;AACAtB,IAAAA,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,EAA6BK,qBAA7B,GAAqD,KAArD;AACAd,IAAAA,eAAe;AAChB,GALoB,EAKlB,CAACA,eAAD,CALkB,CAArB;AAMA,QAAMwD,wBAAwB,GAAG3F,KAAK,CAAC4F,OAAN,CAAc,MAAM3F,QAAQ,CAACkC,eAAD,CAA5B,EAA+C,CAACA,eAAD,CAA/C,CAAjC;AACA,QAAM0D,sBAAsB,GAAG7F,KAAK,CAACoC,WAAN,CAAkB,CAACQ,EAAD,EAAK2C,MAAL,EAAaO,QAAb,KAA0B;AACzE,QAAI,CAACrE,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,CAAD,IAAiC,CAACnB,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,EAA6BI,UAAnE,EAA+E;AAC7E;AACD,KAHwE,CAGvE;;;AAGF,UAAM+C,cAAc,GAAGtE,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,EAA6BC,KAA7B,CAAoC,OAAM3C,UAAU,CAAC4F,QAAD,CAAW,EAA/D,MAAsEP,MAA7F;AACA9D,IAAAA,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,EAA6BK,qBAA7B,GAAqD,KAArD;AACAxB,IAAAA,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,EAA6BC,KAA7B,CAAoC,OAAM3C,UAAU,CAAC4F,QAAD,CAAW,EAA/D,IAAoEP,MAApE;;AAEA,QAAIQ,cAAJ,EAAoB;AAClBJ,MAAAA,wBAAwB;AACzB;AACF,GAb8B,EAa5B,CAACA,wBAAD,CAb4B,CAA/B;AAcA,QAAMK,gBAAgB,GAAGhG,KAAK,CAACoC,WAAN,CAAkBQ,EAAE,IAAI;AAC/C,QAAIqD,sBAAJ;;AAEA,WAAO,CAAC,CAACA,sBAAsB,GAAGxE,gBAAgB,CAACc,OAAjB,CAAyBK,EAAzB,CAA1B,KAA2D,IAA3D,GAAkE,KAAK,CAAvE,GAA2EqD,sBAAsB,CAACjD,UAAnG,KAAkH,KAAzH;AACD,GAJwB,EAItB,EAJsB,CAAzB;AAKA,QAAMkD,uBAAuB,GAAGlG,KAAK,CAACoC,WAAN,CAAkB,MAAM;AACtD,WAAOT,oBAAoB,CAACY,OAA5B;AACD,GAF+B,EAE7B,EAF6B,CAAhC;AAGA,QAAM4D,uBAAuB,GAAGnG,KAAK,CAACoC,WAAN,CAAkBgE,KAAK,IAAI;AACzD,QAAIxE,oBAAoB,CAACW,OAArB,IAAgC6D,KAAK,GAAGzE,oBAAoB,CAACY,OAAjE,EAA0E;AACxEZ,MAAAA,oBAAoB,CAACY,OAArB,GAA+B6D,KAA/B;AACD;AACF,GAJ+B,EAI7B,EAJ6B,CAAhC;AAKA,QAAMC,eAAe,GAAGrG,KAAK,CAACoC,WAAN,CAAkB,MAAM;AAC9CX,IAAAA,gBAAgB,CAACc,OAAjB,GAA2B,EAA3B;AACAJ,IAAAA,eAAe;AAChB,GAHuB,EAGrB,CAACA,eAAD,CAHqB,CAAxB,CA1LgD,CA6LzB;AACvB;;AAEAnC,EAAAA,KAAK,CAACsG,SAAN,CAAgB,MAAM;AACpBnE,IAAAA,eAAe;AAChB,GAFD,EAEG,CAACN,oBAAD,EAAuBC,WAAvB,EAAoCC,eAApC,EAAqDC,YAArD,EAAmEG,eAAnE,CAFH;AAGAxB,EAAAA,0BAA0B,CAACQ,MAAD,EAAS,WAAT,EAAsBgB,eAAtB,CAA1B;AACA,QAAMoE,WAAW,GAAG;AAClBC,IAAAA,gCAAgC,EAAEN,uBADhB;AAElBO,IAAAA,gCAAgC,EAAEN,uBAFhB;AAGlBO,IAAAA,yBAAyB,EAAEV,gBAHT;AAIlBW,IAAAA,qBAAqB,EAAEtF,YAJL;AAKlBuF,IAAAA,4BAA4B,EAAEpB,mBALZ;AAMlBqB,IAAAA,qBAAqB,EAAEnB,YANL;AAOlBoB,IAAAA,kCAAkC,EAAEjB,sBAPlB;AAQlBQ,IAAAA;AARkB,GAApB;AAUAjG,EAAAA,gBAAgB,CAACe,MAAD,EAASoF,WAAT,EAAsB,iBAAtB,CAAhB;AACD,CA/MM","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { debounce, capitalize } from '@mui/material/utils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nexport const rowsMetaStateInitializer = state => _extends({}, state, {\n  rowsMeta: {\n    currentPageTotalHeight: 0,\n    positions: []\n  }\n});\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  const paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const hydrateRowsMeta = React.useCallback(() => {\n    var _pinnedRows$top, _pinnedRows$bottom;\n\n    hasRowWithAutoHeight.current = false;\n    const densityFactor = gridDensityFactorSelector(apiRef.current.state, apiRef.current.instanceId);\n\n    const calculateRowProcessedSizes = row => {\n      if (!rowsHeightLookup.current[row.id]) {\n        rowsHeightLookup.current[row.id] = {\n          sizes: {\n            baseCenter: rowHeightFromDensity\n          },\n          isResized: false,\n          autoHeight: false,\n          needsFirstMeasurement: true // Assume all rows will need to be measured by default\n\n        };\n      }\n\n      const {\n        isResized,\n        needsFirstMeasurement,\n        sizes\n      } = rowsHeightLookup.current[row.id];\n      let baseRowHeight = rowHeightFromDensity;\n      const existingBaseRowHeight = sizes.baseCenter;\n\n      if (isResized) {\n        // Do not recalculate resized row height and use the value from the lookup\n        baseRowHeight = existingBaseRowHeight;\n      } else if (getRowHeightProp) {\n        const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n          densityFactor\n        }));\n\n        if (rowHeightFromUser === 'auto') {\n          if (needsFirstMeasurement) {\n            const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n              densityFactor\n            })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n          } else {\n            baseRowHeight = existingBaseRowHeight;\n          }\n\n          hasRowWithAutoHeight.current = true;\n          rowsHeightLookup.current[row.id].autoHeight = true;\n        } else {\n          // Default back to base rowHeight if getRowHeight returns null or undefined.\n          baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n          rowsHeightLookup.current[row.id].autoHeight = false;\n        }\n      } else {\n        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n      }\n\n      const existingBaseSizes = Object.entries(sizes).reduce((acc, [key, size]) => {\n        if (/^base[A-Z]/.test(key)) {\n          acc[key] = size;\n        }\n\n        return acc;\n      }, {}); // We use an object to make simple to check if a height is already added or not\n\n      const initialHeights = _extends({}, existingBaseSizes, {\n        baseCenter: baseRowHeight\n      });\n\n      if (getRowSpacing) {\n        var _spacing$top, _spacing$bottom;\n\n        const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n        const spacing = getRowSpacing(_extends({}, row, {\n          isFirstVisible: indexRelativeToCurrentPage === 0,\n          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n          indexRelativeToCurrentPage\n        }));\n        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n      }\n\n      const processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n      rowsHeightLookup.current[row.id].sizes = processedSizes;\n      return processedSizes;\n    };\n\n    const positions = [];\n    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n      positions.push(acc);\n      let maximumBaseSize = 0;\n      let otherSizes = 0;\n      const processedSizes = calculateRowProcessedSizes(row);\n      Object.entries(processedSizes).forEach(([size, value]) => {\n        if (/^base[A-Z]/.test(size)) {\n          maximumBaseSize = value > maximumBaseSize ? value : maximumBaseSize;\n        } else {\n          otherSizes += value;\n        }\n      });\n      return acc + maximumBaseSize + otherSizes;\n    }, 0);\n    pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight,\n          positions\n        }\n      });\n    });\n\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows]);\n  const getRowHeight = React.useCallback(rowId => {\n    const height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.baseCenter : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n\n  const getRowInternalSizes = rowId => {\n    var _rowsHeightLookup$cur;\n\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n\n  const setRowHeight = React.useCallback((id, height) => {\n    rowsHeightLookup.current[id].sizes.baseCenter = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const debouncedHydrateRowsMeta = React.useMemo(() => debounce(hydrateRowsMeta), [hydrateRowsMeta]);\n  const storeMeasuredRowHeight = React.useCallback((id, height, position) => {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n\n    const needsHydration = rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] = height;\n\n    if (needsHydration) {\n      debouncedHydrateRowsMeta();\n    }\n  }, [debouncedHydrateRowsMeta]);\n  const rowHasAutoHeight = React.useCallback(id => {\n    var _rowsHeightLookup$cur2;\n\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  const getLastMeasuredRowIndex = React.useCallback(() => {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  const setLastMeasuredRowIndex = React.useCallback(index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []);\n  const resetRowHeights = React.useCallback(() => {\n    rowsHeightLookup.current = {};\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(() => {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  const rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight,\n    resetRowHeights\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};"]},"metadata":{},"sourceType":"module"}