{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { styled } from '@mui/material/styles';\nimport { defaultMemoize } from 'reselect';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridTabIndexColumnHeaderSelector, gridTabIndexCellSelector, gridFocusColumnHeaderSelector } from '../focus/gridFocusStateSelector';\nimport { gridDensityHeaderHeightSelector, gridDensityHeaderGroupingMaxDepthSelector, gridDensityTotalHeaderHeightSelector } from '../density/densitySelector';\nimport { gridFilterActiveItemsLookupSelector } from '../filter/gridFilterSelector';\nimport { gridSortColumnLookupSelector } from '../sorting/gridSortingSelector';\nimport { gridColumnMenuSelector } from '../columnMenu/columnMenuSelector';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { GridColumnHeaderItem } from '../../../components/columnHeaders/GridColumnHeaderItem';\nimport { getFirstColumnIndexToRender } from '../columns/gridColumnsUtils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { getRenderableIndexes } from '../virtualization/useGridVirtualScroller';\nimport { GridColumnGroupHeader } from '../../../components/columnHeaders/GridColumnGroupHeader';\nimport { isDeepEqual } from '../../../utils/utils'; // TODO: add the possibility to switch this value if needed for customization\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MERGE_EMPTY_CELLS = true;\nconst GridColumnHeaderRow = styled('div', {\n  name: 'MuiDataGrid',\n  slot: 'ColumnHeaderRow',\n  overridesResolver: (props, styles) => styles.columnHeaderRow\n})(() => ({\n  display: 'flex'\n}));\n\nfunction isUIEvent(event) {\n  return !!event.target;\n}\n\nexport const useGridColumnHeaders = props => {\n  const {\n    innerRef: innerRefProp,\n    minColumnIndex = 0\n  } = props;\n  const [dragCol, setDragCol] = React.useState('');\n  const [resizeCol, setResizeCol] = React.useState('');\n  const apiRef = useGridApiContext();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);\n  const cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);\n  const headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);\n  const headerGroupingMaxDepth = useGridSelector(apiRef, gridDensityHeaderGroupingMaxDepthSelector);\n  const totalHeaderHeight = useGridSelector(apiRef, gridDensityTotalHeaderHeightSelector);\n  const filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);\n  const sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);\n  const columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);\n  const rootProps = useGridRootProps();\n  const innerRef = React.useRef(null);\n  const handleInnerRef = useForkRef(innerRefProp, innerRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const prevScrollLeft = React.useRef(0);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  React.useEffect(() => {\n    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;\n  }, [apiRef]); // memoize `getFirstColumnIndexToRender`, since it's called on scroll\n\n  const getFirstColumnIndexToRenderRef = React.useRef(defaultMemoize(getFirstColumnIndexToRender, {\n    equalityCheck: (a, b) => ['firstColumnIndex', 'minColumnIndex', 'columnBuffer'].every(key => a[key] === b[key])\n  }));\n  const updateInnerPosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex,\n      columnBuffer: rootProps.columnBuffer,\n      firstRowToRender,\n      lastRowToRender,\n      apiRef,\n      visibleRows: currentPage.rows\n    });\n    const offset = firstColumnToRender > 0 ? prevScrollLeft.current - columnPositions[firstColumnToRender] : prevScrollLeft.current;\n    innerRef.current.style.transform = `translate3d(${-offset}px, 0px, 0px)`;\n  }, [columnPositions, minColumnIndex, rootProps.columnBuffer, apiRef, currentPage.rows, rootProps.rowBuffer]);\n  React.useLayoutEffect(() => {\n    if (renderContext) {\n      updateInnerPosition(renderContext);\n    }\n  }, [renderContext, updateInnerPosition]);\n  const handleScroll = React.useCallback(({\n    left,\n    renderContext: nextRenderContext = null\n  }, event) => {\n    var _prevRenderContext$cu, _prevRenderContext$cu2;\n\n    if (!innerRef.current) {\n      return;\n    } // Ignore vertical scroll.\n    // Excepts the first event which sets the previous render context.\n\n\n    if (prevScrollLeft.current === left && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {\n      return;\n    }\n\n    prevScrollLeft.current = left; // We can only update the position when we guarantee that the render context has been\n    // rendered. This is achieved using ReactDOM.flushSync or when the context doesn't change.\n\n    let canUpdateInnerPosition = false;\n\n    if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {\n      // ReactDOM.flushSync cannot be called on `scroll` events fired inside effects\n      if (isUIEvent(event)) {\n        // To prevent flickering, the inner position can only be updated after the new context has\n        // been rendered. ReactDOM.flushSync ensures that the state changes will happen before\n        // updating the position.\n        ReactDOM.flushSync(() => {\n          setRenderContext(nextRenderContext);\n        });\n        canUpdateInnerPosition = true;\n      } else {\n        setRenderContext(nextRenderContext);\n      }\n\n      prevRenderContext.current = nextRenderContext;\n    } else {\n      canUpdateInnerPosition = true;\n    } // Pass directly the render context to avoid waiting for the next render\n\n\n    if (nextRenderContext && canUpdateInnerPosition) {\n      updateInnerPosition(nextRenderContext);\n    }\n  }, [updateInnerPosition]);\n  const handleColumnResizeStart = React.useCallback(params => setResizeCol(params.field), []);\n  const handleColumnResizeStop = React.useCallback(() => setResizeCol(''), []);\n  const handleColumnReorderStart = React.useCallback(params => setDragCol(params.field), []);\n  const handleColumnReorderStop = React.useCallback(() => setDragCol(''), []);\n  useGridApiEventHandler(apiRef, 'columnResizeStart', handleColumnResizeStart);\n  useGridApiEventHandler(apiRef, 'columnResizeStop', handleColumnResizeStop);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragStart', handleColumnReorderStart);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragEnd', handleColumnReorderStop);\n  useGridApiEventHandler(apiRef, 'rowsScroll', handleScroll); // Helper for computation common between getColumnHeaders and getColumnGroupHeaders\n\n  const getColumnsToRender = params => {\n    const {\n      renderContext: nextRenderContext = renderContext,\n      minFirstColumn = minColumnIndex,\n      maxLastColumn = visibleColumns.length\n    } = params || {};\n\n    if (!nextRenderContext) {\n      return null;\n    }\n\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex: minFirstColumn,\n      columnBuffer: rootProps.columnBuffer,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const lastColumnToRender = Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    return {\n      renderedColumns,\n      firstColumnToRender,\n      lastColumnToRender,\n      minFirstColumn,\n      maxLastColumn\n    };\n  };\n\n  const getColumnHeaders = (params, other = {}) => {\n    const columnsToRender = getColumnsToRender(params);\n\n    if (columnsToRender == null) {\n      return null;\n    }\n\n    const {\n      renderedColumns,\n      firstColumnToRender\n    } = columnsToRender;\n    const columns = [];\n\n    for (let i = 0; i < renderedColumns.length; i += 1) {\n      const column = renderedColumns[i];\n      const columnIndex = firstColumnToRender + i;\n      const isFirstColumn = columnIndex === 0;\n      const hasTabbableElement = !(tabIndexState === null && cellTabIndexState === null);\n      const tabIndex = tabIndexState !== null && tabIndexState.field === column.field || isFirstColumn && !hasTabbableElement ? 0 : -1;\n      const hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === column.field;\n      const open = columnMenuState.open && columnMenuState.field === column.field;\n      columns.push( /*#__PURE__*/_jsx(GridColumnHeaderItem, _extends({}, sortColumnLookup[column.field], {\n        columnMenuOpen: open,\n        filterItemsCounter: filterColumnLookup[column.field] && filterColumnLookup[column.field].length,\n        headerHeight: headerHeight,\n        isDragging: column.field === dragCol,\n        column: column,\n        colIndex: columnIndex,\n        isResizing: resizeCol === column.field,\n        isLastColumn: columnIndex === visibleColumns.length - 1,\n        extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n        hasFocus: hasFocus,\n        tabIndex: tabIndex\n      }, other), column.field));\n    }\n\n    return /*#__PURE__*/_jsx(GridColumnHeaderRow, {\n      role: \"row\",\n      \"aria-rowindex\": headerGroupingMaxDepth + 1,\n      children: columns\n    });\n  };\n\n  const getParents = (path = [], depth) => path.slice(0, depth + 1);\n\n  const getColumnGroupHeaders = params => {\n    if (headerGroupingMaxDepth === 0) {\n      return null;\n    }\n\n    const columnsToRender = getColumnsToRender(params);\n\n    if (columnsToRender == null || columnsToRender.renderedColumns.length === 0) {\n      return null;\n    }\n\n    const {\n      renderedColumns,\n      firstColumnToRender,\n      lastColumnToRender,\n      maxLastColumn\n    } = columnsToRender;\n    const columns = [];\n    const headerToRender = [];\n\n    for (let depth = 0; depth < headerGroupingMaxDepth; depth += 1) {\n      var _visibleColumns$first, _visibleColumns$first2, _visibleColumns$first3; // Initialize the header line with a grouping item containing all the columns on the left of the virtualization which are in the same group as the first group to render\n\n\n      const initialHeader = [];\n      let leftOverflow = 0;\n      let columnIndex = firstColumnToRender - 1;\n      const firstColumnToRenderGroup = (_visibleColumns$first = visibleColumns[firstColumnToRender]) == null ? void 0 : (_visibleColumns$first2 = _visibleColumns$first.groupPath) == null ? void 0 : _visibleColumns$first2[depth]; // The array of parent is used to manage empty grouping cell\n      // When two empty grouping cell are next to each other, we merge them if the belong to the same group.\n\n      const firstColumnToRenderGroupParents = getParents((_visibleColumns$first3 = visibleColumns[firstColumnToRender]) == null ? void 0 : _visibleColumns$first3.groupPath, depth);\n\n      while (firstColumnToRenderGroup !== null && columnIndex >= minColumnIndex && (_visibleColumns$colum = visibleColumns[columnIndex]) != null && _visibleColumns$colum.groupPath && isDeepEqual(getParents((_visibleColumns$colum2 = visibleColumns[columnIndex]) == null ? void 0 : _visibleColumns$colum2.groupPath, depth), firstColumnToRenderGroupParents)) {\n        var _visibleColumns$colum, _visibleColumns$colum2, _column$computedWidth;\n\n        const column = visibleColumns[columnIndex];\n        leftOverflow += (_column$computedWidth = column.computedWidth) != null ? _column$computedWidth : 0;\n\n        if (initialHeader.length === 0) {\n          var _column$computedWidth2;\n\n          initialHeader.push({\n            width: (_column$computedWidth2 = column.computedWidth) != null ? _column$computedWidth2 : 0,\n            fields: [column.field],\n            groupId: firstColumnToRenderGroup,\n            groupParents: firstColumnToRenderGroupParents,\n            colIndex: columnIndex\n          });\n        } else {\n          var _column$computedWidth3;\n\n          initialHeader[0].width += (_column$computedWidth3 = column.computedWidth) != null ? _column$computedWidth3 : 0;\n          initialHeader[0].fields.push(column.field);\n          initialHeader[0].colIndex = columnIndex;\n        }\n\n        columnIndex -= 1;\n      }\n\n      const depthInfo = renderedColumns.reduce((aggregated, column, i) => {\n        var _column$computedWidth7;\n\n        const lastItem = aggregated[aggregated.length - 1];\n\n        if (column.groupPath && column.groupPath.length > depth) {\n          var _column$computedWidth5;\n\n          if (lastItem && lastItem.groupId === column.groupPath[depth]) {\n            var _column$computedWidth4; // Merge with the previous columns\n\n\n            return [...aggregated.slice(0, aggregated.length - 1), _extends({}, lastItem, {\n              width: lastItem.width + ((_column$computedWidth4 = column.computedWidth) != null ? _column$computedWidth4 : 0),\n              fields: [...lastItem.fields, column.field]\n            })];\n          } // Create a new grouping\n\n\n          return [...aggregated, {\n            groupId: column.groupPath[depth],\n            groupParents: getParents(column.groupPath, depth),\n            width: (_column$computedWidth5 = column.computedWidth) != null ? _column$computedWidth5 : 0,\n            fields: [column.field],\n            colIndex: firstColumnToRender + i\n          }];\n        }\n\n        if (MERGE_EMPTY_CELLS && lastItem && lastItem.groupId === null && isDeepEqual(getParents(column.groupPath, depth), lastItem.groupParents)) {\n          var _column$computedWidth6; // We merge with previous column\n\n\n          return [...aggregated.slice(0, aggregated.length - 1), _extends({}, lastItem, {\n            width: lastItem.width + ((_column$computedWidth6 = column.computedWidth) != null ? _column$computedWidth6 : 0),\n            fields: [...lastItem.fields, column.field]\n          })];\n        } // We create new empty cell\n\n\n        return [...aggregated, {\n          groupId: null,\n          groupParents: getParents(column.groupPath, depth),\n          width: (_column$computedWidth7 = column.computedWidth) != null ? _column$computedWidth7 : 0,\n          fields: [column.field],\n          colIndex: firstColumnToRender + i\n        }];\n      }, initialHeader);\n      columnIndex = lastColumnToRender;\n      const lastColumnToRenderGroup = depthInfo[depthInfo.length - 1].groupId;\n\n      while (lastColumnToRenderGroup !== null && columnIndex < maxLastColumn && (_visibleColumns$colum3 = visibleColumns[columnIndex]) != null && _visibleColumns$colum3.groupPath && ((_visibleColumns$colum4 = visibleColumns[columnIndex]) == null ? void 0 : (_visibleColumns$colum5 = _visibleColumns$colum4.groupPath) == null ? void 0 : _visibleColumns$colum5[depth]) === lastColumnToRenderGroup) {\n        var _visibleColumns$colum3, _visibleColumns$colum4, _visibleColumns$colum5, _column$computedWidth8;\n\n        const column = visibleColumns[columnIndex];\n        depthInfo[depthInfo.length - 1].width += (_column$computedWidth8 = column.computedWidth) != null ? _column$computedWidth8 : 0;\n        depthInfo[depthInfo.length - 1].fields.push(column.field);\n        columnIndex += 1;\n      }\n\n      headerToRender.push({\n        leftOverflow,\n        elements: [...depthInfo]\n      });\n    }\n\n    headerToRender.forEach((depthInfo, depthIndex) => {\n      columns.push( /*#__PURE__*/_jsx(GridColumnHeaderRow, {\n        style: {\n          height: `${headerHeight}px`,\n          transform: `translateX(-${depthInfo.leftOverflow}px)`\n        },\n        role: \"row\",\n        \"aria-rowindex\": depthIndex + 1,\n        children: depthInfo.elements.map(({\n          groupId,\n          width,\n          fields,\n          colIndex\n        }, groupIndex) => {\n          return /*#__PURE__*/_jsx(GridColumnGroupHeader, {\n            groupId: groupId,\n            width: width,\n            fields: fields,\n            colIndex: colIndex,\n            depth: depthIndex,\n            isLastColumn: colIndex === visibleColumns.length - fields.length,\n            extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n            maxDepth: headerToRender.length,\n            height: headerHeight\n          }, groupIndex);\n        })\n      }, depthIndex));\n    });\n    return columns;\n  };\n\n  const rootStyle = {\n    minHeight: totalHeaderHeight,\n    maxHeight: totalHeaderHeight,\n    lineHeight: `${headerHeight}px`\n  };\n  return {\n    renderContext,\n    getColumnHeaders,\n    getColumnGroupHeaders,\n    isDragging: !!dragCol,\n    getRootProps: (other = {}) => _extends({\n      style: rootStyle\n    }, other),\n    getInnerProps: () => ({\n      ref: handleInnerRef,\n      role: 'rowgroup'\n    })\n  };\n};","map":{"version":3,"sources":["/home/moryno/Development/Project/Final-Project/Moringa-Hackerank/client/node_modules/@mui/x-data-grid/hooks/features/columnHeaders/useGridColumnHeaders.js"],"names":["_extends","React","ReactDOM","useForkRef","styled","defaultMemoize","useGridApiContext","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnPositionsSelector","gridTabIndexColumnHeaderSelector","gridTabIndexCellSelector","gridFocusColumnHeaderSelector","gridDensityHeaderHeightSelector","gridDensityHeaderGroupingMaxDepthSelector","gridDensityTotalHeaderHeightSelector","gridFilterActiveItemsLookupSelector","gridSortColumnLookupSelector","gridColumnMenuSelector","useGridRootProps","useGridApiEventHandler","GridColumnHeaderItem","getFirstColumnIndexToRender","useGridVisibleRows","getRenderableIndexes","GridColumnGroupHeader","isDeepEqual","jsx","_jsx","MERGE_EMPTY_CELLS","GridColumnHeaderRow","name","slot","overridesResolver","props","styles","columnHeaderRow","display","isUIEvent","event","target","useGridColumnHeaders","innerRef","innerRefProp","minColumnIndex","dragCol","setDragCol","useState","resizeCol","setResizeCol","apiRef","visibleColumns","columnPositions","tabIndexState","cellTabIndexState","columnHeaderFocus","headerHeight","headerGroupingMaxDepth","totalHeaderHeight","filterColumnLookup","sortColumnLookup","columnMenuState","rootProps","useRef","handleInnerRef","renderContext","setRenderContext","prevRenderContext","prevScrollLeft","currentPage","useEffect","current","columnHeadersContainerElementRef","scrollLeft","getFirstColumnIndexToRenderRef","equalityCheck","a","b","every","key","updateInnerPosition","useCallback","nextRenderContext","firstRowToRender","lastRowToRender","firstIndex","firstRowIndex","lastIndex","lastRowIndex","minFirstIndex","maxLastIndex","rows","length","buffer","rowBuffer","firstColumnToRender","firstColumnIndex","columnBuffer","visibleRows","offset","style","transform","useLayoutEffect","handleScroll","left","_prevRenderContext$cu","_prevRenderContext$cu2","lastColumnIndex","canUpdateInnerPosition","flushSync","handleColumnResizeStart","params","field","handleColumnResizeStop","handleColumnReorderStart","handleColumnReorderStop","getColumnsToRender","minFirstColumn","maxLastColumn","lastColumnToRender","Math","min","renderedColumns","slice","getColumnHeaders","other","columnsToRender","columns","i","column","columnIndex","isFirstColumn","hasTabbableElement","tabIndex","hasFocus","open","push","columnMenuOpen","filterItemsCounter","isDragging","colIndex","isResizing","isLastColumn","extendRowFullWidth","disableExtendRowFullWidth","role","children","getParents","path","depth","getColumnGroupHeaders","headerToRender","_visibleColumns$first","_visibleColumns$first2","_visibleColumns$first3","initialHeader","leftOverflow","firstColumnToRenderGroup","groupPath","firstColumnToRenderGroupParents","_visibleColumns$colum","_visibleColumns$colum2","_column$computedWidth","computedWidth","_column$computedWidth2","width","fields","groupId","groupParents","_column$computedWidth3","depthInfo","reduce","aggregated","_column$computedWidth7","lastItem","_column$computedWidth5","_column$computedWidth4","_column$computedWidth6","lastColumnToRenderGroup","_visibleColumns$colum3","_visibleColumns$colum4","_visibleColumns$colum5","_column$computedWidth8","elements","forEach","depthIndex","height","map","groupIndex","maxDepth","rootStyle","minHeight","maxHeight","lineHeight","getRootProps","getInnerProps","ref"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { styled } from '@mui/material/styles';\nimport { defaultMemoize } from 'reselect';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridTabIndexColumnHeaderSelector, gridTabIndexCellSelector, gridFocusColumnHeaderSelector } from '../focus/gridFocusStateSelector';\nimport { gridDensityHeaderHeightSelector, gridDensityHeaderGroupingMaxDepthSelector, gridDensityTotalHeaderHeightSelector } from '../density/densitySelector';\nimport { gridFilterActiveItemsLookupSelector } from '../filter/gridFilterSelector';\nimport { gridSortColumnLookupSelector } from '../sorting/gridSortingSelector';\nimport { gridColumnMenuSelector } from '../columnMenu/columnMenuSelector';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { GridColumnHeaderItem } from '../../../components/columnHeaders/GridColumnHeaderItem';\nimport { getFirstColumnIndexToRender } from '../columns/gridColumnsUtils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { getRenderableIndexes } from '../virtualization/useGridVirtualScroller';\nimport { GridColumnGroupHeader } from '../../../components/columnHeaders/GridColumnGroupHeader';\nimport { isDeepEqual } from '../../../utils/utils'; // TODO: add the possibility to switch this value if needed for customization\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MERGE_EMPTY_CELLS = true;\nconst GridColumnHeaderRow = styled('div', {\n  name: 'MuiDataGrid',\n  slot: 'ColumnHeaderRow',\n  overridesResolver: (props, styles) => styles.columnHeaderRow\n})(() => ({\n  display: 'flex'\n}));\n\nfunction isUIEvent(event) {\n  return !!event.target;\n}\n\nexport const useGridColumnHeaders = props => {\n  const {\n    innerRef: innerRefProp,\n    minColumnIndex = 0\n  } = props;\n  const [dragCol, setDragCol] = React.useState('');\n  const [resizeCol, setResizeCol] = React.useState('');\n  const apiRef = useGridApiContext();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);\n  const cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);\n  const headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);\n  const headerGroupingMaxDepth = useGridSelector(apiRef, gridDensityHeaderGroupingMaxDepthSelector);\n  const totalHeaderHeight = useGridSelector(apiRef, gridDensityTotalHeaderHeightSelector);\n  const filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);\n  const sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);\n  const columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);\n  const rootProps = useGridRootProps();\n  const innerRef = React.useRef(null);\n  const handleInnerRef = useForkRef(innerRefProp, innerRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const prevScrollLeft = React.useRef(0);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  React.useEffect(() => {\n    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;\n  }, [apiRef]); // memoize `getFirstColumnIndexToRender`, since it's called on scroll\n\n  const getFirstColumnIndexToRenderRef = React.useRef(defaultMemoize(getFirstColumnIndexToRender, {\n    equalityCheck: (a, b) => ['firstColumnIndex', 'minColumnIndex', 'columnBuffer'].every(key => a[key] === b[key])\n  }));\n  const updateInnerPosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex,\n      columnBuffer: rootProps.columnBuffer,\n      firstRowToRender,\n      lastRowToRender,\n      apiRef,\n      visibleRows: currentPage.rows\n    });\n    const offset = firstColumnToRender > 0 ? prevScrollLeft.current - columnPositions[firstColumnToRender] : prevScrollLeft.current;\n    innerRef.current.style.transform = `translate3d(${-offset}px, 0px, 0px)`;\n  }, [columnPositions, minColumnIndex, rootProps.columnBuffer, apiRef, currentPage.rows, rootProps.rowBuffer]);\n  React.useLayoutEffect(() => {\n    if (renderContext) {\n      updateInnerPosition(renderContext);\n    }\n  }, [renderContext, updateInnerPosition]);\n  const handleScroll = React.useCallback(({\n    left,\n    renderContext: nextRenderContext = null\n  }, event) => {\n    var _prevRenderContext$cu, _prevRenderContext$cu2;\n\n    if (!innerRef.current) {\n      return;\n    } // Ignore vertical scroll.\n    // Excepts the first event which sets the previous render context.\n\n\n    if (prevScrollLeft.current === left && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {\n      return;\n    }\n\n    prevScrollLeft.current = left; // We can only update the position when we guarantee that the render context has been\n    // rendered. This is achieved using ReactDOM.flushSync or when the context doesn't change.\n\n    let canUpdateInnerPosition = false;\n\n    if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {\n      // ReactDOM.flushSync cannot be called on `scroll` events fired inside effects\n      if (isUIEvent(event)) {\n        // To prevent flickering, the inner position can only be updated after the new context has\n        // been rendered. ReactDOM.flushSync ensures that the state changes will happen before\n        // updating the position.\n        ReactDOM.flushSync(() => {\n          setRenderContext(nextRenderContext);\n        });\n        canUpdateInnerPosition = true;\n      } else {\n        setRenderContext(nextRenderContext);\n      }\n\n      prevRenderContext.current = nextRenderContext;\n    } else {\n      canUpdateInnerPosition = true;\n    } // Pass directly the render context to avoid waiting for the next render\n\n\n    if (nextRenderContext && canUpdateInnerPosition) {\n      updateInnerPosition(nextRenderContext);\n    }\n  }, [updateInnerPosition]);\n  const handleColumnResizeStart = React.useCallback(params => setResizeCol(params.field), []);\n  const handleColumnResizeStop = React.useCallback(() => setResizeCol(''), []);\n  const handleColumnReorderStart = React.useCallback(params => setDragCol(params.field), []);\n  const handleColumnReorderStop = React.useCallback(() => setDragCol(''), []);\n  useGridApiEventHandler(apiRef, 'columnResizeStart', handleColumnResizeStart);\n  useGridApiEventHandler(apiRef, 'columnResizeStop', handleColumnResizeStop);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragStart', handleColumnReorderStart);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragEnd', handleColumnReorderStop);\n  useGridApiEventHandler(apiRef, 'rowsScroll', handleScroll); // Helper for computation common between getColumnHeaders and getColumnGroupHeaders\n\n  const getColumnsToRender = params => {\n    const {\n      renderContext: nextRenderContext = renderContext,\n      minFirstColumn = minColumnIndex,\n      maxLastColumn = visibleColumns.length\n    } = params || {};\n\n    if (!nextRenderContext) {\n      return null;\n    }\n\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex: minFirstColumn,\n      columnBuffer: rootProps.columnBuffer,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const lastColumnToRender = Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    return {\n      renderedColumns,\n      firstColumnToRender,\n      lastColumnToRender,\n      minFirstColumn,\n      maxLastColumn\n    };\n  };\n\n  const getColumnHeaders = (params, other = {}) => {\n    const columnsToRender = getColumnsToRender(params);\n\n    if (columnsToRender == null) {\n      return null;\n    }\n\n    const {\n      renderedColumns,\n      firstColumnToRender\n    } = columnsToRender;\n    const columns = [];\n\n    for (let i = 0; i < renderedColumns.length; i += 1) {\n      const column = renderedColumns[i];\n      const columnIndex = firstColumnToRender + i;\n      const isFirstColumn = columnIndex === 0;\n      const hasTabbableElement = !(tabIndexState === null && cellTabIndexState === null);\n      const tabIndex = tabIndexState !== null && tabIndexState.field === column.field || isFirstColumn && !hasTabbableElement ? 0 : -1;\n      const hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === column.field;\n      const open = columnMenuState.open && columnMenuState.field === column.field;\n      columns.push( /*#__PURE__*/_jsx(GridColumnHeaderItem, _extends({}, sortColumnLookup[column.field], {\n        columnMenuOpen: open,\n        filterItemsCounter: filterColumnLookup[column.field] && filterColumnLookup[column.field].length,\n        headerHeight: headerHeight,\n        isDragging: column.field === dragCol,\n        column: column,\n        colIndex: columnIndex,\n        isResizing: resizeCol === column.field,\n        isLastColumn: columnIndex === visibleColumns.length - 1,\n        extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n        hasFocus: hasFocus,\n        tabIndex: tabIndex\n      }, other), column.field));\n    }\n\n    return /*#__PURE__*/_jsx(GridColumnHeaderRow, {\n      role: \"row\",\n      \"aria-rowindex\": headerGroupingMaxDepth + 1,\n      children: columns\n    });\n  };\n\n  const getParents = (path = [], depth) => path.slice(0, depth + 1);\n\n  const getColumnGroupHeaders = params => {\n    if (headerGroupingMaxDepth === 0) {\n      return null;\n    }\n\n    const columnsToRender = getColumnsToRender(params);\n\n    if (columnsToRender == null || columnsToRender.renderedColumns.length === 0) {\n      return null;\n    }\n\n    const {\n      renderedColumns,\n      firstColumnToRender,\n      lastColumnToRender,\n      maxLastColumn\n    } = columnsToRender;\n    const columns = [];\n    const headerToRender = [];\n\n    for (let depth = 0; depth < headerGroupingMaxDepth; depth += 1) {\n      var _visibleColumns$first, _visibleColumns$first2, _visibleColumns$first3;\n\n      // Initialize the header line with a grouping item containing all the columns on the left of the virtualization which are in the same group as the first group to render\n      const initialHeader = [];\n      let leftOverflow = 0;\n      let columnIndex = firstColumnToRender - 1;\n      const firstColumnToRenderGroup = (_visibleColumns$first = visibleColumns[firstColumnToRender]) == null ? void 0 : (_visibleColumns$first2 = _visibleColumns$first.groupPath) == null ? void 0 : _visibleColumns$first2[depth]; // The array of parent is used to manage empty grouping cell\n      // When two empty grouping cell are next to each other, we merge them if the belong to the same group.\n\n      const firstColumnToRenderGroupParents = getParents((_visibleColumns$first3 = visibleColumns[firstColumnToRender]) == null ? void 0 : _visibleColumns$first3.groupPath, depth);\n\n      while (firstColumnToRenderGroup !== null && columnIndex >= minColumnIndex && (_visibleColumns$colum = visibleColumns[columnIndex]) != null && _visibleColumns$colum.groupPath && isDeepEqual(getParents((_visibleColumns$colum2 = visibleColumns[columnIndex]) == null ? void 0 : _visibleColumns$colum2.groupPath, depth), firstColumnToRenderGroupParents)) {\n        var _visibleColumns$colum, _visibleColumns$colum2, _column$computedWidth;\n\n        const column = visibleColumns[columnIndex];\n        leftOverflow += (_column$computedWidth = column.computedWidth) != null ? _column$computedWidth : 0;\n\n        if (initialHeader.length === 0) {\n          var _column$computedWidth2;\n\n          initialHeader.push({\n            width: (_column$computedWidth2 = column.computedWidth) != null ? _column$computedWidth2 : 0,\n            fields: [column.field],\n            groupId: firstColumnToRenderGroup,\n            groupParents: firstColumnToRenderGroupParents,\n            colIndex: columnIndex\n          });\n        } else {\n          var _column$computedWidth3;\n\n          initialHeader[0].width += (_column$computedWidth3 = column.computedWidth) != null ? _column$computedWidth3 : 0;\n          initialHeader[0].fields.push(column.field);\n          initialHeader[0].colIndex = columnIndex;\n        }\n\n        columnIndex -= 1;\n      }\n\n      const depthInfo = renderedColumns.reduce((aggregated, column, i) => {\n        var _column$computedWidth7;\n\n        const lastItem = aggregated[aggregated.length - 1];\n\n        if (column.groupPath && column.groupPath.length > depth) {\n          var _column$computedWidth5;\n\n          if (lastItem && lastItem.groupId === column.groupPath[depth]) {\n            var _column$computedWidth4;\n\n            // Merge with the previous columns\n            return [...aggregated.slice(0, aggregated.length - 1), _extends({}, lastItem, {\n              width: lastItem.width + ((_column$computedWidth4 = column.computedWidth) != null ? _column$computedWidth4 : 0),\n              fields: [...lastItem.fields, column.field]\n            })];\n          } // Create a new grouping\n\n\n          return [...aggregated, {\n            groupId: column.groupPath[depth],\n            groupParents: getParents(column.groupPath, depth),\n            width: (_column$computedWidth5 = column.computedWidth) != null ? _column$computedWidth5 : 0,\n            fields: [column.field],\n            colIndex: firstColumnToRender + i\n          }];\n        }\n\n        if (MERGE_EMPTY_CELLS && lastItem && lastItem.groupId === null && isDeepEqual(getParents(column.groupPath, depth), lastItem.groupParents)) {\n          var _column$computedWidth6;\n\n          // We merge with previous column\n          return [...aggregated.slice(0, aggregated.length - 1), _extends({}, lastItem, {\n            width: lastItem.width + ((_column$computedWidth6 = column.computedWidth) != null ? _column$computedWidth6 : 0),\n            fields: [...lastItem.fields, column.field]\n          })];\n        } // We create new empty cell\n\n\n        return [...aggregated, {\n          groupId: null,\n          groupParents: getParents(column.groupPath, depth),\n          width: (_column$computedWidth7 = column.computedWidth) != null ? _column$computedWidth7 : 0,\n          fields: [column.field],\n          colIndex: firstColumnToRender + i\n        }];\n      }, initialHeader);\n      columnIndex = lastColumnToRender;\n      const lastColumnToRenderGroup = depthInfo[depthInfo.length - 1].groupId;\n\n      while (lastColumnToRenderGroup !== null && columnIndex < maxLastColumn && (_visibleColumns$colum3 = visibleColumns[columnIndex]) != null && _visibleColumns$colum3.groupPath && ((_visibleColumns$colum4 = visibleColumns[columnIndex]) == null ? void 0 : (_visibleColumns$colum5 = _visibleColumns$colum4.groupPath) == null ? void 0 : _visibleColumns$colum5[depth]) === lastColumnToRenderGroup) {\n        var _visibleColumns$colum3, _visibleColumns$colum4, _visibleColumns$colum5, _column$computedWidth8;\n\n        const column = visibleColumns[columnIndex];\n        depthInfo[depthInfo.length - 1].width += (_column$computedWidth8 = column.computedWidth) != null ? _column$computedWidth8 : 0;\n        depthInfo[depthInfo.length - 1].fields.push(column.field);\n        columnIndex += 1;\n      }\n\n      headerToRender.push({\n        leftOverflow,\n        elements: [...depthInfo]\n      });\n    }\n\n    headerToRender.forEach((depthInfo, depthIndex) => {\n      columns.push( /*#__PURE__*/_jsx(GridColumnHeaderRow, {\n        style: {\n          height: `${headerHeight}px`,\n          transform: `translateX(-${depthInfo.leftOverflow}px)`\n        },\n        role: \"row\",\n        \"aria-rowindex\": depthIndex + 1,\n        children: depthInfo.elements.map(({\n          groupId,\n          width,\n          fields,\n          colIndex\n        }, groupIndex) => {\n          return /*#__PURE__*/_jsx(GridColumnGroupHeader, {\n            groupId: groupId,\n            width: width,\n            fields: fields,\n            colIndex: colIndex,\n            depth: depthIndex,\n            isLastColumn: colIndex === visibleColumns.length - fields.length,\n            extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n            maxDepth: headerToRender.length,\n            height: headerHeight\n          }, groupIndex);\n        })\n      }, depthIndex));\n    });\n    return columns;\n  };\n\n  const rootStyle = {\n    minHeight: totalHeaderHeight,\n    maxHeight: totalHeaderHeight,\n    lineHeight: `${headerHeight}px`\n  };\n  return {\n    renderContext,\n    getColumnHeaders,\n    getColumnGroupHeaders,\n    isDragging: !!dragCol,\n    getRootProps: (other = {}) => _extends({\n      style: rootStyle\n    }, other),\n    getInnerProps: () => ({\n      ref: handleInnerRef,\n      role: 'rowgroup'\n    })\n  };\n};"]},"metadata":{},"sourceType":"module"}